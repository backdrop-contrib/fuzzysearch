<?php

// $Id$

/*
 * Implementation of fuzzy search indexing
 * by Blake Lucchesi (www.boldsource.com)
 * Algorithm: n-gram indexing and retrieval
 * Code written for Google's Summer of Code 2007
 *
 */

/**
 * Matches Unicode character classes to exclude from the search index.
 *
 * See: http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category_Values
 *
 * The index only contains the following character classes:
 * Lu     Letter, Uppercase
 * Ll     Letter, Lowercase
 * Lt     Letter, Titlecase
 * Lo     Letter, Other
 * Nd     Number, Decimal Digit
 * No     Number, Other
 */
define('PREG_CLASS_SEARCH_EXCLUDE',
'\x{0}-\x{2f}\x{3a}-\x{40}\x{5b}-\x{60}\x{7b}-\x{bf}\x{d7}\x{f7}\x{2b0}-'.
'\x{385}\x{387}\x{3f6}\x{482}-\x{489}\x{559}-\x{55f}\x{589}-\x{5c7}\x{5f3}-'.
'\x{61f}\x{640}\x{64b}-\x{65e}\x{66a}-\x{66d}\x{670}\x{6d4}\x{6d6}-\x{6ed}'.
'\x{6fd}\x{6fe}\x{700}-\x{70f}\x{711}\x{730}-\x{74a}\x{7a6}-\x{7b0}\x{901}-'.
'\x{903}\x{93c}\x{93e}-\x{94d}\x{951}-\x{954}\x{962}-\x{965}\x{970}\x{981}-'.
'\x{983}\x{9bc}\x{9be}-\x{9cd}\x{9d7}\x{9e2}\x{9e3}\x{9f2}-\x{a03}\x{a3c}-'.
'\x{a4d}\x{a70}\x{a71}\x{a81}-\x{a83}\x{abc}\x{abe}-\x{acd}\x{ae2}\x{ae3}'.
'\x{af1}-\x{b03}\x{b3c}\x{b3e}-\x{b57}\x{b70}\x{b82}\x{bbe}-\x{bd7}\x{bf0}-'.
'\x{c03}\x{c3e}-\x{c56}\x{c82}\x{c83}\x{cbc}\x{cbe}-\x{cd6}\x{d02}\x{d03}'.
'\x{d3e}-\x{d57}\x{d82}\x{d83}\x{dca}-\x{df4}\x{e31}\x{e34}-\x{e3f}\x{e46}-'.
'\x{e4f}\x{e5a}\x{e5b}\x{eb1}\x{eb4}-\x{ebc}\x{ec6}-\x{ecd}\x{f01}-\x{f1f}'.
'\x{f2a}-\x{f3f}\x{f71}-\x{f87}\x{f90}-\x{fd1}\x{102c}-\x{1039}\x{104a}-'.
'\x{104f}\x{1056}-\x{1059}\x{10fb}\x{10fc}\x{135f}-\x{137c}\x{1390}-\x{1399}'.
'\x{166d}\x{166e}\x{1680}\x{169b}\x{169c}\x{16eb}-\x{16f0}\x{1712}-\x{1714}'.
'\x{1732}-\x{1736}\x{1752}\x{1753}\x{1772}\x{1773}\x{17b4}-\x{17db}\x{17dd}'.
'\x{17f0}-\x{180e}\x{1843}\x{18a9}\x{1920}-\x{1945}\x{19b0}-\x{19c0}\x{19c8}'.
'\x{19c9}\x{19de}-\x{19ff}\x{1a17}-\x{1a1f}\x{1d2c}-\x{1d61}\x{1d78}\x{1d9b}-'.
'\x{1dc3}\x{1fbd}\x{1fbf}-\x{1fc1}\x{1fcd}-\x{1fcf}\x{1fdd}-\x{1fdf}\x{1fed}-'.
'\x{1fef}\x{1ffd}-\x{2070}\x{2074}-\x{207e}\x{2080}-\x{2101}\x{2103}-\x{2106}'.
'\x{2108}\x{2109}\x{2114}\x{2116}-\x{2118}\x{211e}-\x{2123}\x{2125}\x{2127}'.
'\x{2129}\x{212e}\x{2132}\x{213a}\x{213b}\x{2140}-\x{2144}\x{214a}-\x{2b13}'.
'\x{2ce5}-\x{2cff}\x{2d6f}\x{2e00}-\x{3005}\x{3007}-\x{303b}\x{303d}-\x{303f}'.
'\x{3099}-\x{309e}\x{30a0}\x{30fb}-\x{30fe}\x{3190}-\x{319f}\x{31c0}-\x{31cf}'.
'\x{3200}-\x{33ff}\x{4dc0}-\x{4dff}\x{a015}\x{a490}-\x{a716}\x{a802}\x{a806}'.
'\x{a80b}\x{a823}-\x{a82b}\x{d800}-\x{f8ff}\x{fb1e}\x{fb29}\x{fd3e}\x{fd3f}'.
'\x{fdfc}-\x{fe6b}\x{feff}-\x{ff0f}\x{ff1a}-\x{ff20}\x{ff3b}-\x{ff40}\x{ff5b}-'.
'\x{ff65}\x{ff70}\x{ff9e}\x{ff9f}\x{ffe0}-\x{fffd}');


/**
 * hook_menu
 */
function fuzzysearch_menu($may_cache) {
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/fuzzysearch',
      'title' => t('Fuzzy Search Settings'),
      'description' => 'Fuzzy Search Settings allow you to index certain node data',
      'callback' => 'fuzzysearch_admin',
      'access' => user_access('administer fuzzysearch'),
      'type' => MENU_NORMAL_ITEM,
    );
  }
  else {
    $items[] = array(
      'path' => 'fuzzysearch/results',
      'title' => t('Search'),
      'callback' => 'fuzzysearch_show_results',
      'access' => user_access('fuzzysearch content'),
      'type' => MENU_DYNAMIC_ITEM,
    );
  }
  return $items;
}

/**
 * Implementation of hook_perm
 */
function fuzzysearch_perm() {
  return array('administer fuzzysearch', 'fuzzysearch content');
}
/**
 * Build the administration settings panel
 */
function fuzzysearch_admin() {
  $output .= '<p>Use the checkbox below to reindex your sites nodes</p>';
  $output .= drupal_get_form('fuzzysearch_admin_form');
  $output .= drupal_get_form('fuzzysearch_scoring');
  return $output;
}

/**
 * Module Administration (clear index)
 */

function fuzzysearch_admin_form() {
  
  $form['update'] = array(
    '#title' => t('Fuzzy Search Settings'),
    '#type' => 'fieldset'
  );
  $form['update']['reindex'] = array(
    '#type' => 'checkbox',
    '#title' => 'Clear Index',
    '#description' => t('Check the box and click submit to re-index all nodes on the site during the next cron run.'),
    '#default_value' => false
  );
  
  $form['update']['debug_score'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display Scoring'),
    '#description' => t('If selected, the completeness and score of the results will be shown below each result'),
    '#default_value' => variable_get('search_debug_score', false)
  );
  
  $form['update']['completeness'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum Completeness'),
    '#description' => t('Enter  value between 0 and 100) to set the minimum match completeness percent required in the returned results.'),
    '#default_value' => variable_get('search_min_completeness', 40),
    '#weight' => 7
  );
  
  $form['update']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
    '#weight' => 10
  );

  return $form;  
}

function fuzzysearch_admin_form_submit($form_id, $form_values) {
  if ($form_values['reindex']) {
    // Delete all nodes to be queued so we can read all of them
    db_query("DELETE FROM {search_index_queue}");
    
    $query = db_query("SELECT nid FROM {node}");
    while ($row = db_fetch_object($query)) {
      fuzzysearch_reindex($row->nid, 'fuzzysearch');
    }
    drupal_set_message('Nodes ready for reindexing, please run cron to update the index.');
  }
  variable_set('search_min_completeness', $form_values['completeness']);
  variable_set('search_debug_score', $form_values['debug_score']);
}


/**
 * Implementation of hook_nodeapi()
 * 
 * Used to remove node data from index upon deletion and
 * queue a node for indexing on insertion
 */

function fuzzysearch_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'update':
    case 'insert':
      fuzzysearch_reindex($node->nid, 'fuzzysearch');
      break;
    case 'delete':
      db_query("DELETE FROM {search_fuzzy_index} WHERE nid = %d", $node->nid);
      break;
  }
}

/**
 * Scoring Management - Allow the site administrator to assign
 * importance factors to each of the scores returned by modules
 * that implement hook_search_score()
 */

function fuzzysearch_scoring() {
  
  $form['scoring'] = array(
    '#title' => t('Scoring Adjustment'),
    '#description' => t('Choose a multiplier for each of the score factors. Changing these settings will require all content to be reindexed.'),
    '#type' => 'fieldset',
  );

  // Allow multipliers to range from 10 = max impact on score, to 0 = no impact on score.
  $select_values = array(
    10 => 10,
    9 => 9,
    8 => 8,
    7 => 7,
    6 => 6,
    5 => 5,
    4 => 4,
    3 => 3,
    2 => 2,
    1 => 1, 
    0 => 0);
  
  //  Return all the score modifiers using hook_search_score
  //  expects each score modifier to return an array defining the title and description
  //  of the modifier  
  $scores = module_invoke_all('search_score', 'settings', null);
  
  foreach ($scores as $key => $score) {
    $form_index = $score['id'];
    $form['scoring'][$form_index] = array(
      '#title' => $score['title'],
      '#description' => $score['description'],
      '#type' => 'select',
      '#options' => $select_values,
      '#default_value' => variable_get('search_scoring_'. $score['id'], 5),
    );
  }

  $form['scoring']['submit'] = array(
    '#value' => t('Update Score Factors'),
    '#type' => 'submit',
  );
  return $form;
}

/**
 * Save the score modifiers as set in the administrative form.
 */

function fuzzysearch_scoring_submit($form_id, $form_values) {
  foreach ($form_values as $key => $value) {
    if ($key != 'op' || $key != 'submit' || $key != 'form_token' || $key != 'form_id') {
      variable_set('search_scoring_'. $key, $value);
    }
  }
  drupal_set_message('Score factor multipliers have been updated');
}

/**
 * Provide an external API function that allows modules to flag a node for reindexing
 *
 * @param $nid - nid of the node to be reindexed
 * @param $module - name of the module flagging the node
 */
function fuzzysearch_reindex($nid, $module) {
  $query = db_query("SELECT * FROM {search_index_queue} WHERE nid = %d", $nid);
  if (!db_result($query)) {
    db_query("INSERT INTO {search_index_queue} (nid, module, timestamp) VALUES (%d, '%s', %d)", $nid, $module, time());
  }
}


/**
 * Implementation of hook_cron
 * We use this query to find all the nodes that need to be indexed or
 * reindexed. Instead of the normal search module which uses timestamps to
 * find out which nodes need indexing this allows other modules to specify
 * individual nodes for indexing without changing the created/updated
 * timestamp
 */
function fuzzysearch_cron() {
  $query = db_query("SELECT nid FROM {search_index_queue} LIMIT 0, 150");
  while ($result = db_fetch_object($query)) {
    fuzzysearch_index($result->nid);
  }
}

/**
 * Index the node data in the fuzzy index table
 * 
 * @param nid
 *  The node id of the node being indexed
 * @return 
 *  Returns true on success, false on failure
 *
 */
function fuzzysearch_index($nid) {
  
  // First step is removing past index
  db_query("DELETE FROM {search_fuzzy_index} WHERE nid = %d", $nid);
  
  $node = node_load($nid);
  
  // Index node title
  $text .= '<h1> '. $node->title .' </h1>';
  
  // Index node body
  $text .= $node->body;
  
  // Implementation of nodeapi's update_index op.
  $outside_text = module_invoke_all('nodeapi', $node, 'update index', null, null);
  if ($outside_text) {
    foreach ($outside_text as $content) {
      $text .= ' '.$content;
    }
  }
  
  // Insert code to allow other modules to filter indexed text before indexing
  
  // Multipliers for scores of words inside certain HTML tags.
  // Note: 'a' must be included for link ranking to work.
  $tags = array('h1' => 10,
                'h2' => 9,
                'h3' => 8,
                'h4' => 7,
                'h5' => 6,
                'h6' => 5,
                'u' => 2,
                'b' => 2,
                'i' => 2,
                'strong' => 2,
                'em' => 2,
                'a' => 5);
  
  // Strip off all ignored tags to speed up processing
  $text = strip_tags($text, '<'. implode('><', array_keys($tags)) .'>');

  // Strip all stop words if stop words are enabled
  if (variable_get('search_stop_words', false)) {
    module_invoke_all('search_filter', &$text);
  }
  
  //  Allow other modules to modify the score of the node based on each owns calculations
  //  the sum of all the scores added to each node is then multiplied by the score of the word,
  //  this allows for faster result queries because all scoring is done at the time of indexing
  $hook_scores = module_invoke_all('search_score', 'index', $node);
  
  //  Build the final score multiplier for each node based on returned multipliers from other nodes
  foreach ($hook_scores as $score) {
    $multiplier = variable_get('search_scoring_'. $score['id'], 5);
    $hook_score += $score['score'] * $multiplier;
  }

  ## BEGIN INDEXING CONTENT
  // Find all words not located within tags (score = 1)
  $content = preg_replace('/<([A-Z][A-Z0-9]*)[^>]*>(.*?)<\/\1>/i', '', $text);
  $content = fuzzysearch_cleanse($content);

  $words = array();
  $index_words = array();
  $words = preg_split('/\s/', $content, -1, PREG_SPLIT_NO_EMPTY);

  // Build the index array with scores
  foreach ($words as $word) {
    $key = array_search($word, $index_words);
    if ($key === FALSE) {
      $index_words[] = $word;
      $index_scores[] = 1;
    }
    else {
      $index_scores[$key] += 1;
    }
  }

  // Find all words located within tags (score > 1)
  preg_match_all('/<([A-Z][A-Z0-9]*)([^>]*)>(.*?)<\/\1>/i', $text, $tagged);
  
  // filter through each set of content inbetween tags
  foreach ($tagged[3] as $key => $content) {
    $content = fuzzysearch_cleanse($content);
    $words = preg_split('/\s/', $content, -1, PREG_SPLIT_NO_EMPTY);
    $tag = $tagged[1][$key];
    $tag_score = $tags[$tag];
    
    foreach ($words as $word) {
      $key = array_search($word, $index_words);
      if ($key === FALSE) {
        $index_words[] = $word;
        $index_scores[] = $tag_score;
      }
      else {
        $index_scores[$key] += $tag_score;
      }
    } 
  }  

  foreach ($index_words as $key => $word) {
    // ensure that as each word is indexed it receives a unique id 
    // independent of the node it is in.
    $word_id = db_next_id("{search_fuzzy_index}_word_id");
    fuzzysearch_index_insert($word, $word_id, $nid, $index_scores[$key], $hook_score);
  }

  // Update the node table to make indexed = 1;
  db_query("DELETE FROM {search_index_queue} WHERE nid = %d", $nid); 
}

/**
 * Insert the words into the database as they are indexed
 * @param $word: word to insert into the index
 * @param $nid: the node id that is to be associated with this word
 * @param $word_score: score given to the word based on the tag it is in
 * @param $node_score: score modifier given to the node from hook_search_score
 */
function fuzzysearch_index_insert($word, $word_id, $nid, $word_score, $node_score){
  $length = fuzzysearch_utf8_strlen($word);
  $nlength = variable_get('search_nlength', 3);
  //  Ensure that having all score modifiers set to 0 will not affect our natural scoring
  if ($node_score > 0) {
    $score = $word_score * $node_score;          
  } 
  else {
    $score = $word_score;
  }
    
  if ($length > $nlength) {
    //  Calculate how complete the ngram is compared to the length of the word
    $completeness = 100 / ($length - $nlength + 1);
    //  Create ngrams and index them
    for ($i=0; $i < ($length - $nlength + 1); $i++) {
      db_query("INSERT INTO {search_fuzzy_index} (nid, word_id, ngram, completeness, score) VALUES (%d, %d, '%s', %f, %f)",
        $nid, $word_id, fuzzysearch_utf8_substr($word, $i, $nlength), $completeness, $score);
    }
  }
  else {
    //  The ngram is the same length as the actual word so it is complete
    $completeness = 100;
    //  Index the ngram
    db_query("INSERT INTO {search_fuzzy_index} (nid, word_id, ngram, completeness, score) VALUES (%d, %d, '%s', %f, %f)",
      $nid, $word_id, $word, $completeness, $score);
  }
}

/**
 * Strip all non alphanumeric characters from a string
 */
function fuzzysearch_cleanse($text) {
  $text = strip_tags($text);
  $text = strtolower($text);
  return preg_replace('/['. PREG_CLASS_SEARCH_EXCLUDE . ']+/u', ' ', $text);
}

/**
 * Helper function to split UTF8 characters
 * Credits: posted on php.net by: www.yeap.lv
 */
function fuzzysearch_utf8_substr($str,$from,$len) {
  return preg_replace('#^(?:[\x00-\x7F]|[\xC0-\xFF][\x80-\xBF]+){0,'.$from.'}'.
                         '((?:[\x00-\x7F]|[\xC0-\xFF][\x80-\xBF]+){0,'.$len.'}).*#s',
                         '$1',$str);
}

/**
 * Helper function to count the proper length of UTF8 characters
 * Credits: posted on php.net by anpaza@mail.ru
 */
function fuzzysearch_utf8_strlen($str) {
  return preg_match_all('/[\x00-\x7F\xC0-\xFD]/', $str, $dummy);
}


/**
 * Form to search the index
 */
function fuzzysearch_box_form() {
  $form['#base'] = 'fuzzysearch_form';
  $form['keys'] = array(
    '#type' => 'textfield',
    '#size' => 15,
    '#default_value' => '',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );
  return $form;
}

/**
 * Theme the output of the search block
 */
function theme_fuzzysearch_box_form($form) {
  $output .= '<div class="container-inline">'. drupal_render($form['keys']) . drupal_render($form['submit']) .'</div>';
  $output .= drupal_render($form);
  return $output;
}

/**
 * Implementation of hook_block().
 */
function fuzzysearch_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Fuzzy search form');
    return $blocks;
  }
  else if ($op == 'view' && user_access('fuzzysearch content')) {
    $block['content'] = drupal_get_form('fuzzysearch_box_form');
    $block['subject'] = t('Search');
    return $block;
  }
}

/**
 * Form to search the index
 */
function fuzzysearch_form($keys = '') {
  $form['keys'] = array(
    '#title' => t('Enter search phrase'),
    '#type' => 'textfield',
    '#size' => 35,
    '#default_value' => $keys,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );
  return $form;
}

/**
 * Redirect the search terms to the result callback and
 * provide the keys as part of the path so that the search
 * can be linked to.
 */
function fuzzysearch_form_submit($form_id, $form_values) {
  drupal_goto('fuzzysearch/results/'. check_plain(trim($form_values['keys'])));
}

/**
 * Output formatting for the search form
 */
function theme_fuzzysearch_form($form) {
  $output .= '<div class="search-form">'. drupal_render($form['keys']) . drupal_render($form['submit']) .'</div>';
  $output .= drupal_render($form);
  return $output;
}

/**
 * Process the search query
 */
function fuzzysearch_process($query) {
  global $user;
  // if no keys were entered do not display anything below the search form
  if(!$query){
    return;
  }
  $nlength = variable_get('search_nlength', 3);

  $words = explode(' ', $query);
  foreach ($words as $k => $word) {
    // TODO Change type of query based on boolean operators
    $length = fuzzysearch_utf8_strlen($word);
    if ($length > $nlength) {
      // Determine lengths which we want to search for
      if ($length > 3) {
        // 5 letter word matches down to 4 letter words
        $comp = 1 / (4 - $nlength + 1);
      }
      if ($length > 5) {
        // 6 and 7 letter words match down to 5 letter words
        $comp = 1 / (5 - $nlength + 1);
      }
      if ($length > 7) {
        // anything larger matches down 2 letters than its own length
        $comp = 1 / ($length - 2 - $nlength + 1);
      }
      $comp = number_format($comp + .001, 3) * 100;
      for ($i=0; $i < $length - 2; $i++) { 
        $clause .= " (ngram = '". fuzzysearch_utf8_substr($word, $i, $nlength) ."' AND completeness <". $comp .") OR";
//        $keys[] = fuzzysearch_utf8_substr($word, $i, $nlength);
      }
    }
    else{
      $clause .= " ngram = '". $word ."' OR";
    }
  }

  $clause = preg_replace("/ OR$/", '', $clause);

  // $length = count($keys);
  // for ($i=0; $i < $length; $i++) { 
  //   $clause .= " ngram = '". $keys[$i] ."'";
  //   if ($i != $length - 1) {
  //     $clause .= ' OR';
  //   }
  // }

  // TODO: Fix the minimum completeness so that a single qgram match doesn't necessarily return a match
  $min_completeness = check_plain(variable_get('search_min_completeness', 40));
//  if($user->uid == 1){
    $query = pager_query(db_rewrite_sql("SELECT n.nid, SUM(percent) AS completeness, SUM(score) AS score FROM (SELECT n.nid, SUM(completeness) percent, SUM(score) score FROM {search_fuzzy_index} AS s LEFT JOIN {node} AS n ON (n.nid = s.nid) WHERE (($clause) AND n.status = 1) GROUP BY word_id HAVING percent > $min_completeness) AS n GROUP BY n.nid ORDER BY completeness DESC, score DESC"), 10, 0, "SELECT COUNT(DISTINCT(n.nid)) FROM (SELECT n.nid, CEILING(SUM(completeness)) completeness, SUM(score) score FROM {search_fuzzy_index} AS n WHERE $clause GROUP BY word_id HAVING SUM(completeness) > $min_completeness ORDER BY completeness DESC, score DESC) AS n");
  // }
  // else {
  //   $query = pager_query(db_rewrite_sql("SELECT n.nid, CEILING(SUM(completeness)) AS completeness, SUM(score) AS score FROM ((SELECT n.nid, SUM(completeness) completeness, SUM(score) score FROM {search_fuzzy_index} AS n WHERE $clause GROUP BY word_id HAVING SUM(completeness) > $min_completeness ORDER BY completeness DESC, score DESC) AS n GROUP BY n.nid ORDER BY CEILING(SUM(completeness)) DESC, score DESC"), 10, 0, "SELECT COUNT(DISTINCT(n.nid)) FROM (SELECT n.nid, CEILING(SUM(completeness)) completeness, SUM(score) score FROM {search_fuzzy_index} AS n WHERE $clause GROUP BY word_id HAVING SUM(completeness) > $min_completeness ORDER BY completeness DESC, score DESC) AS n");    
  // }
  while ($row = db_fetch_object($query)) {
    $node = node_load($row->nid);
    $node->score = $row->score;
    $node->completeness = $row->completeness;
    $results[] = $node;
  }
  if ($results) {
    $output .= theme('fuzzysearch_results', $results);
    $output .= theme('pager', NULL, 10);
  }
  else {
    $output = '<p>'. t('Sorry no matches were found.') .'</p>';
  }
  return $output;
}

/**
 * Gather results from the index and build result page
 */
function fuzzysearch_show_results($keys = '') {
  drupal_set_title(check_plain($keys));
  drupal_add_css($base_path . drupal_get_path('module', 'fuzzysearch') .'/fuzzysearch.css', 'module');
  $output .= '<div class="clear-block">';
  $output .= drupal_get_form('fuzzysearch_form', $keys);
  $output .= '</div>';
  $output .= fuzzysearch_process($keys); 
  return $output;
}

/**
 * Theme the search results
 */
function theme_fuzzysearch_results($results) {
  $output .= '<div class="box">';
  $output .= '<h2>'. t('Search Results') .'</h2>'; 
  $output .= '<dl class="search-results">';
  foreach ($results as $result) {
    $i++;
    $odd = $i%2 ? 'odd' : 'even';
    $output .= '<dt class="title">'. l(t($result->title), 'node/'. $result->nid) .'</dt>';
    $output .= '<dd>';
    $output .= '<p>'. $result->teaser .'</p>';
    if (variable_get('search_debug_score', false)) {
      $output .= '<p>Completeness: '. $result->completeness .' Score: '. $result->score .'</p>';
    }
    $output .= '</dd>';
  }
  $output .= '</dl></div>';
  return $output;
}